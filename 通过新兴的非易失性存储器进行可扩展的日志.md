# 通过新兴的非易失性存储器进行可扩展的日志  
## abatract   
&emsp;新兴的字节可寻址非易失性存储器（NVM）从根本上改变了事务日志的设计原则。它可能会使提交前刷新的需求失效，因为日志记录在写入时立即就会保持不变。分布式日志记录 -  DRAM时代的单节点系统曾经禁止使用的技术 - 由于NVM的非易失性和高性能成为缓解日志瓶颈的有希望的解决方案。   
&emsp; 本文提出了在多核、多套接字硬件上实现NVM和分布式日志记录的方法。 我们确定分布式日志记录带来的挑战并讨论解决方案。为了保护在基于NVM的系统中提交的工作，我们提出了被动组提交，这是一种利用现有硬件和组提交的轻量级实用方法。我们期望持久的处理器缓存是保护提交的工作和构建可靠的、可伸缩的基于NVM的系统的最终解决方案。我们使用日志记录密集型工作负载评估分布式日志记录，并表明分布式日志记录可以比现代DBMS中的集中式日志记录实现高出约3倍的速度，并且被动组提交仅会产生微小的开销。  
## 1.引言
&emsp;自从90年代初首次亮相以来，ARIES [28]一直是事务记录的事实标准。尽管多核硬件和大型主存储器很普遍，但大多数系统仍然使用集中式ARIES样式的日志来缓冲DRAM中的日志记录，直到提交请求强制它们进行稳定存储。考虑到易失性、快速DRAM和非易失性、慢速磁盘，这种先刷新后提交原则通过用（理想情况下）单个顺序I/O替换事务占用空间中所有脏页的随机回写来强化日志，从而提高了性能，而没有丢失工作的风险。然而，集中式日志记录已经成为当今大规模并行硬件的一个重要瓶颈[21,22]。
&emsp; 新兴的字节可寻址、非易失性存储器(NVM)技术，如相变存储器(PCM)[44]和自旋转移扭矩RAM（STT-RAM）[14]，正在从根本上改变日志的设计原理。这些NVM产品具有高性能，良好的可扩展性和低功耗[25]。例如，STT-RAM可以实现约10ns的写延迟[18]，甚至比DRAM快。通过适当的缓存，精心设计的PCM也可以匹配DRAM性能[4]。类DRAM性能和非易失性的结合使NVM成为日志记录的一个有吸引力的候选: 日志记录在写入后立即保留，因此事务不需要在提交时强制将日志记录到磁盘。然后可以采用各种简化来提高日志记录性能和可靠性，例如删除异步和组提交[12,37]，并使用后端日志存储统一日志缓冲区[10]。然后可以进行各种简化以提高日志记录性能和可靠性，例如删除异步和组提交[12，37]，以及将日志缓冲区与后端日志存储统一[10]。尽管基于NVM的日志记录带来了延迟和单线程性能的改进，但由于集中式设计，仍然存在对日志头的争用。图1显示了Shore-MT[20]（一个为现代硬件优化的原型数据库系统）在48核四插槽服务器上运行日志密集型工作负载时的时间分解。随着系统负载的增加，集中式日志的争用成为主要的开销。虽然很少用于单节点系统，但我们发现分布式日志有可能弥补这种情况。在本文中，我们展示了NVM增强的分布式日志记录可以消除现代多核和多插槽硬件的日志瓶颈。我们为每个日志配备一个基于NVM的缓冲区，通过加载和存储指令访问。事务缓冲提交记录后立即提交事务，日志记录仅在日志缓冲区已满时转储到磁盘。  
&emsp;采用分布式日志记录和NVM都不是小事。 分布式日志记录带来两个主要挑战: 如何将日志记录分配给日志（日志空间分区），以及如何防止分布式日志中的漏洞，而不会在提交时施加过多的开销。ARIES风格的恢复支持按页或事务对日志进行分区，即分别将涉及给定页或事务的所有日志记录分配给同一日志。正如我们将在后面的部分中所示，采用这两种方法都会涉及不同的设计挑战和性能影响. 字节可寻址的NVM也不是灵丹妙药。
&emsp;现代处理器严重依赖多级缓存来提高性能。虽然日志记录在到达NVM后立即成为持久记录，但默认情况下，它们首先缓存在易失性处理器缓存中（“写回”缓存）。数据保持高速缓存，直到某些事件从高速缓存中驱逐该值（例如，高速缓存冲突或OS明确请求高速缓存刷新），同时电源故障将丢失缓存在SRAM高速缓存中的日志记录。将日志记录分散在多个日志中会使情况恶化:在访问的所有日志中的所有记录都已达到持久存储之前，事务无法提交。在事务级分区的情况下, 事务还必须确保其足迹中的页的所有以前的日志记录都已持久化,即使它们驻留在事务从未访问过的日志中也是如此。显式跟踪这些依赖关系非常复杂，并且在每次提交时将日志记录强制到磁盘都会产生不可接受的I / O开销[21]。   
&emsp;基于现有硬件，我们提出了被动组提交，一种用于基于NVM的分布式日志记录的轻量级组提交协议，以保护在失败时提交的工作。与大多数NVM日志记录提议不同，被动组提交不依赖于 nvm 特定的硬件支持来自定义内存屏障 [9], 并且在将每个日志写入缓冲到 NVM [10, 35] 后也不会发出障碍。相反，被动组提交建立在商品处理器功能上 - 写入组合和内存障碍 - 并利用组提交来确保在事务完成提交之前所有必需的日志记录都是持久的。   
&emsp;被动组提交非常轻量级，并且为配备NVM的现有硬件提供了显着的性能优势，但实际上是一种临时解决方案。对于未来基于NVM的系统，我们认为最终的解决方案不是一种新型的内存屏障，而是一种持久的处理器缓存[23,45]。持久的高速缓存确保写操作一离开CPU的存储缓冲区就有效地持久化，并且可以通过片内NVM或基于超级电容的解决方案来实现，只要断电，该解决方案就会耗尽高速缓存。持久缓存在很大程度上对软件是透明的。在某些处理器上，唯一的要求是使用内存防护，以防止存储重新排序（x86不会重新排序存储，但其他架构如ARM更具侵略性）。通过允许缓存层次结构吸收绝大多数写入，持久缓存还有助于延长NVM的生命周期。虽然尚未广泛使用，但它们可以使用现有技术快速开发：原型已经建成[29,32]。通过消除对被动组提交和写入组合的需要，持久高速缓存将进一步改进和简化我们提出的设计。由于它们易于使用、高性能和底层NVM的磨损率降低，我们期望随着装备NVM的系统变得更加流行，耐用的缓存将变得广泛可用。    
&emsp;总之，我们做出以下贡献：
+ 我们展示了NVM允许实际的分布式日志记录，从而消除了单个集中日志带来的可扩展性挑战。
+ 我们提出了被动组提交，这是一个轻量级的组提交协议，它利用现有的硬件支持进行写组合，以保护失败时提交的工作。
+ 我们展示了持久缓存架构有望简化分布式日志记录并提高其在基于NVM的系统中的性能。

&emsp;请注意，此工作的重点不是创建另一个基于NVM的日志，以消除I / O延迟。相反，我们建议利用NVMin对分布式日志记录的支持，目标是减轻所有集中式日志记录方案所遭受的争用瓶颈（基于NVM或其他方式）。
&emsp;在本文的其余部分中，我们将在第2节中提供有关NVM和日志记录的背景知识。在第3节中，我们讨论分布式日志记录带来的设计挑战并提出解决方案。第4节详细介绍了从硬件/OS保护已提交工作和预期对NVM的支持的方法。第5节介绍了评估结果。 我们总结了相关工作，并分别在第6节和第7节中得出结论。  
## 2 背景
&emsp; 在本节中，我们将简要介绍NVM技术并讨论如何将它们用于数据库日志记录。 最后，我们简要概述了数据库日志记录。
### 2.1  字节可寻址的非易失性存储器
&emsp;由于其可扩展性，能效和非易失性，一些NVM技术 - 例如PCM [44]，忆阻器[41]和STT-RAM [14]  - 正在被积极研究作为DRAM的替代品。其他努力集中于NVDIMM，或闪存/电池的DRAM支持[1,43]。虽然基于不同的技术，这些NVM都是字节可寻址的，并且可以与DRAM并排放置在存储器总线上。软件可以使用普通的加载和存储指令来访问它们。写入时数据立即持久，不需要恒定电压来维持数据。我们在下面总结了这些NVM技术。   
&emsp;正在成熟/生产NVM。虽然大多数NVM技术才刚刚开始推出，但企业级产品已经面市——对于成本合理的应用而言——以电池或NAND闪存支持的DIMM形式出现[1，43]。这些产品已经批量生产并可在市场上销售。它们通常首先在DRAM中缓冲数据，以允许完全DDR3速度，然后定期将数据保存在闪存中。 这种NV-DIMM可以成为分布式日志记录的一种方便的嵌入式解决方案。   
&emsp; 另一种成熟技术是PCM，它通过改变其底层材料的状态来存储数据。PCM电池由两个电极和相变材料组成，可以响应电信号在低电阻状态和高电阻状态之间切换[44]。原始PCM表现出比DRAM（20ns-50ns）更长的延迟（80ns-1μs）和有限的编程周期（108-109）[6,25];已经提出了各种补偿机制[7,17,25,36,46]。我们预计未来的PCM产品将配备一个电容支持的SRAM缓冲器（就像今天的一些磁盘），以提供具有合理寿命的接近DRAM的性能。  
&emsp;未来有希望的候选者。忆阻器[41]被称为“第四基本电路元件”，由两层二氧化钛和线电极组成。它的电阻随着电流的流动而变化，从而存储信息。报告的延迟范围从数百ps到数十ns[38]。100TB忆阻器驱动器可能在2018年之前可用[27]。STT-RAM [14]是另一种有前景的NVM技术，可提供10-25ns的延迟，使其成为片上高速缓存和存储的理想选择[18]。这些NVM技术距离市场还有几年的时间，但它们的高性能和非易失性将进一步简化NVM作为可扩展日志记录的插入式解决方案的应用。  
&emsp;闪存/电池支持的NV-DIMM和PCM是迄今为止最有希望的NVM候选产品，因为它们已经上市或即将上市。尽管写入速度较慢且耐用性有限，但人们普遍认为商用PCM产品将采用电容反馈SRAM / DRAM缓冲器，以隐藏延迟并避免过早磨损。此外，我们的方案顺序写入日志记录，并且没有部分覆盖，这使得日志记录成为NVM的理想候选应用程序；我们并不认为耐力是一个大问题。足够快的NVM（例如，闪存支持的NV-DIMM）可以用作直接替代品。 我们的方法不依赖于具有特定时序或磨损特性的NVM。  
### 2.2 预写日志（WAL)
&emsp; 最早由Mohan等人提出。 [28]ARIES日志记录在商业数据库系统和开放源码数据库系统中都很流行。事务在脏页到达磁盘之前记录单个全局日志中的所有更新。为了隐藏快速内存和慢速磁盘之间的性能差异，日志记录缓存在集中式DRAM缓冲区中，并仅在事务提交时强制进入磁盘。日志通常由锁存器或互斥锁保护，必须在写入日志缓冲区之前通过插入事务获取。尽管采用了多核和多插槽硬件，集中式日志记录仍然主导着数据库引擎设计。  
&emsp;当事务提交时，必须将其缓冲的日志记录强制到磁盘以确保可恢复性。每个日志记录由单调递增的日志序列号（LSN）唯一标识。每个页面中的LSN表示修改页面的最新日志记录。在恢复期间，分析日志并向前扫描以重复历史记录（“重做”），应用LSN大于其目标页面的日志记录。重做之后，回滚失败的事务（“撤消”）。在每次撤消操作之后写入补偿日志记录（CLR），以确保在恢复期间重复崩溃时，日志记录只撤消一次。  
## 3. 分布式日志  
&emsp; 分布式日志记录通过将日志插入分散到多个物理日志上来缓解了日志记录瓶颈。从历史上看，由于依赖项跟踪和I/O开销，分布式日志记录对于单个节点系统来说是令人望而却步（禁止）的。大多数单节点系统都避免使用分布式日志，甚至分布式系统也使用了托管在专用节点上的集中式日志[26]。NVM使得在单节点系统中使用分布式日志记录成为可能，因为它可能无需提前刷新。只有在日志缓冲区已满时才需要进行日志记录，并使用大量顺序写入来最大化磁盘带宽利用率。   
&emsp; 日志记录与数据库系统中的其他核心组件（例如事务管理器）紧密耦合，并受到恢复的强烈影响: ARIES使用物理日志记录进行重做和逻辑日志记录以进行撤消（生理日志记录）。重做和撤消都有自己的并行模型：在重做期间，可以并行重放对不同页面的修改，而在事务级别并行化撤销。生成日志记录的资源管理器按页或事务选择日志，竞争的恢复并行模式增加了选择正确分区方案的重要性。本节的其余部分讨论了分布式日志记录在前向处理和恢复方面所带来的设计挑战和权衡。  
### 3.1 正向处理（Forward Processing）
&emsp;日志记录的唯一性.在集中式日志中，日志序列号（LSN）唯一标识每个日志记录;使用prevLSN字段将同一事务写入的记录链接在一起，该字段标识由同一事务写入的先前日志记录。当事务中止时，通过跟随prevLSN指针链来撤消日志记录，最新的指针是最近的。但是，LSN不是分布式日志记录中的唯一标识符，因为它们只表示日志记录在日志中的位置，而不记录来自不同日志的记录的相对顺序。在页面级日志空间分区下，事务可以触及任何页面并写入任何日志，并且prevLSN不再允许事务向后跟踪其日志记录。对于事务级日志空间分区，事务仅将日志记录插入单个日志，但是页面LSN在事务中不再是唯一的，因为不同事务生成的更新将转到不同的日志。来自不同日志的记录之间缺乏排序可能会导致恢复管理器跳过应用较新的日志记录，甚至将较旧的日志记录应用于碰巧具有较小LSN的较新日志记录之上。  
&emsp;为了唯一地识别日志记录，我们提出了一个基于逻辑时钟的全局序列号（GSN）[24]。在运行时，每个页面，事务和日志中都会维护一个GSN。页面和日志记录还会永久存储GSN。如果事务要修改页面，则在缓冲池中固定页面将页面和事务GSN设置为max（tx GSN，页面GSN）+ 1; 否则只将事务GSN设置为max（tx GSN，页面GSN）。插入日志记录会将事务和页面GSN都设置为max（tx GSN，页面GSN）+ 1。然后，日志将其GSN设置为max（tx GSN，页面GSN，log GSN）。相同的GSN也存储在正在插入的日志记录中。虽然gsn只是部分排序，但它们唯一地标识日志记录，并为属于任何一个页面、日志或事务的日志记录提供总排序。请注意，对于页级日志空间分区，GSN可能不是必需的，因为相同页的日志记录总是存储在相同的日志中。为了允许事务回滚，每个事务不仅应记录LSN，还应记录存储每个日志记录的日志。虽然不是必需的，但使用GSN可以避免这种复杂的簿记并简化页面级分区的设计。事务级别分区在很大程度上依赖于GSN在正向处理期间正常运行，因为同一页面的日志记录可以通过不同的事务存储在任意日志中。  
&emsp;交叉日志中止。GSN仅部分解决了在分布式日志中跟踪日志记录的问题。一个简单的实现将在正向处理过程中扫描多个日志，以找到具有指定GSN的正确日志记录。为避免昂贵的日志扫描，我们维护一个私有DRAM撤消缓冲区，用于记录每个事务中的日志写入。在商业和开源系统中已经实现了类似的方法，以简化事务回滚[40]。在商业和开源系统中已经实现了类似的方法，以简化事务回滚[40]。缓冲区作为堆栈进行管理（中止重复弹出记录），并在事务结束后丢弃。回滚期间生成的日志记录从不撤消，仅记录在NVM日志缓冲区中。  
&emsp;处理器关联。向多核和多套接字系统的转变带来了非统一内存访问(NUMA)，在这种情况下，内存要么是“本地的”，要么是“远程的”，而后者的访问成本要高得多。可以在任意处理器上调度事务线程，在任何日志上扩展插入，而这些日志又可以在任何NUMA节点中分配（或在所有这些条纹上划线）。如果日志缓冲区和事务线程不在同一个NUMA节点内，如图2（a）所示，日志插入将涉及远程内存访问.由于页面级日志空间分区允许事务写入任何日志，因此访问远程内存是不可避免的，除非事务以限制线程到特定页面集的方式进行调度（例如使用物理逻辑分区[34]）。相反，事务级分区直接适用于多套接字硬件，因为每个事务的写操作都要写入一个日志。如图2(b)所示，可以在每个NUMA节点中分配一个日志，并根据日志所运行的CPU将事务分配给日志。这种方法在插入日志记录时可以消除远程内存访问，提高日志记录性能并释放互连带宽用于其他用途。   
&emsp;检查点。为了加速恢复，ARIES要求在前向处理期间定期检查所有脏页和正在处理的事务。恢复管理器可以直接加载这些表，而不是扫描整个日志以重建它们。分布式日志要求检查点线程了解各个日志，尤其是页面级日志空间分区：必须记录页面GSN，或者应为每个日志生成脏页表。然后，分析过程可以并行处理来自不同日志的日志记录。由于活动事务表是全局的，并且只记录事务状态，因此可以将其存储在预定义的日志（例如，第一个日志）中，并通过预分析步骤进行恢复。另一种方法是生成多个活动事务表，每个日志对应一个，以删除预分析过程。   
&emsp; 日志空间利用率和偏差。在页面级分区下，事务在前向处理期间将日志记录保留在多个日志中，但给定页面的所有记录都存储在同一日志中。如果某些页面特别热，则相应的日志可能会过度使用，而其他日志则不会被利用。与此相反，事务级分区将每个事务的日志记录存储在单个日志中，因此只要操作系统将负载均匀地分布在内核中，日志访问就应该是均匀分布的。事务通常足够短，迁移也很少，因此我们可以根据每个事务首次运行的核心为其分配日志，而对性能影响很小。
### 3.2 Recovery
&emsp;ARIES将恢复分为三个阶段：分析，重做和撤消。分析传递提取在系统失败之前记录的信息（例如，脏页和活动事务的列表），以确定重做和撤消应该如何进行。使用分布式日志，分析过程可以在页面或事务级别进行并行化，但可能首先需要预分析步骤，以检索脏页面和/或活动事务表（如前所述）。分析完成后，ARIES自然支持并行重做和撤消：不同页面的重做可以并行进行，也可以撤消不同的事务。理想情况下, 分布式日志应并行完全恢复, 但日志分区选择都不会与redo和undo完全一致。我们将在本节讨论分布式日志记录如何影响页面和事务级别分区下的恢复。
&emsp;页级日志空间分区。页面分区的分布式日志非常适合并行重做。唯一的区别是，每个重做线程都应该使用来自单个日志的页面，最好是驻留在同一个套接字上。但是，撤消传递需要进行分析，以建立与前向处理期间相同的每个事务日志缓冲区，这可能非常昂贵，因为我们预计绝大多数事务都已提交，只有少数失败的事务需要撤消。此外，如果每个事务缓冲区存储指针而不是日志记录的副本，则并行撤销传递将不得不随机访问多个日志，这对于基于磁盘的系统来说是昂贵的（回想一下，当NVM缓冲区填满时，日志记录会被转移到磁盘上）。可以通过将日志记录复制到每个事务缓冲区来减少开销，或者（如果事务太大，无法以这种方式缓存）使用有效的检查点来确保要撤消的大多数日志记录都在NVM中，从而减少开销。  
&emsp;跟踪由嵌套顶级操作编写的虚拟CLR也会使页面级分区的撤消变得复杂。ARIES使用嵌套的顶级操作和虚拟CLR来表示（通常是物理的）操作，一旦完成就永远不会撤消，即使请求的事务最终中止。例如，B-Tree页面拆分仅影响物理表示（不是数据库中的逻辑内容），并且可以安全地保持跨事务回滚[28]。在嵌套的顶部动作（例如，B树分割）完成之后写入伪CLR，其中prevLSN字段在嵌套的顶部动作开始之前直接指向日志记录。由于虚拟CLR可以覆盖多个日志记录，这些日志记录在页级分区下分布在多个日志上，因此在嵌套的top操作之前跟踪日志记录涉及跨不同的日志跳转。即使嵌套的顶级操作写入的日志记录永远不会被撤消，但在分析过程中仍然需要检查（并可能缓存）它们。   
&emsp;为了简化撤消，我们用系统事务替换嵌套的顶级操作[13]。系统事务仅修改数据库的物理表示，并且不会更改用户可见的任何逻辑内容。因此，系统事务不会获取锁，并且可以从调用事务继承锁存器。当只需要物理更改时，用户事务可以启动系统事务，并在事务完成后继续。系统事务也像用户事务一样生成日志记录，中断的系统事务的回滚与用户事务的回滚相同:它可以安全地通过私有DRAM撤消缓冲区中的日志记录逐个撤消它们。   
&emsp;事务级日志空间分区。对于事务分区日志，并行撤销很简单，因为撤消事务的所有日志记录都驻留在同一个日志中。但是，重做变得更加复杂，因为页面之间的依赖关系可以驻留在任何日志中。并行重放所有日志会导致同一页面的日志记录以任意顺序应用，可能会跳过某些记录。例如，考虑一个事务Tx 1，该事务修改了页面P1并将其记录在具有GSN 50的Log 1上。另一个事务Tx 2修改了相同的页面，但使用GSN 60将其记录在Log 2上。尽管由Tx 2生成的日志记录具有较大的GSN，但其在Log 2中的相对位置（字节偏移）可能早于在Log 1中由Tx 1生成的日志记录，导致由Tx 2生成的日志记录首先应用（假设我们开始同时重做两个日志并以相同的速度继续）。由于重做过程不会应用GSN小于页面GSN的日志记录，因此将跳过由Tx 1生成的记录。   
&emsp;两步重做管道，让人联想到map / reduce，可以有效地解决这个问题：第一阶段使用N个线程扫描日志，直到某个目标GSN，并根据页面ID将日志记录划分为M个桶。然后，M个线程可以对每个桶进行排序，并并行应用更改，而不会有跳过记录的风险。使用这种方法可以实现完全并行性，可用的并行性在N个分区和M个重做线程之间保持平衡。
### 3.3 页面与事务级别分区
&emsp; 图2基于双套接字机器上的一个示例阐明了这两种方法的基本思想。在图2(a)中，每个NUMA节点都有一个从本地内存分配的NVM日志缓冲区。两个事务线程（Tx 1和Tx 2）在两个处理器上运行。该示例假设所有奇数页码的页面都包含在日志1中，而所有偶数页码的页面都包含在另一个日志中。对于这两种设计，检查点记录可以保存在预定义的日志中，也可以为特定日志生成检查点记录，以便于恢复:页面级分区可以为每个日志使用单独的脏页表，而事务级分区可以使用每个日志的活动事务表。   
&emsp;表1从设计挑战的角度比较了这两种方法。通常，事务级分区分布式日志具有直接撤消和跟踪日志记录的功能。但是，由于页面和事务之间的依赖关系，它需要更复杂的重做。ARIES隐式支持页级日志空间分区。它允许轻松的并行重做，但会使事务级并行撤消变得复杂，并生成更多的远程访问。正如我们将在评估结果中显示的，事务级分区在多套接字硬件的正向处理过程中实现了更高的性能，因为它避免了跨越NUMA边界插入日志记录。                
